#!/usr/bin/env python3
"""Main evolution script for Hash Chain Evolver."""

import sys
import os
import random
import subprocess
from pathlib import Path
from datetime import datetime
from utils import (
    is_prime, 
    get_hash_value, 
    log_evolution, 
    update_readme_stats,
    save_state,
    load_state,
    get_step_number,
    ROOT_DIR
)


def get_current_commit_hash():
    """Get the current HEAD commit hash."""
    result = subprocess.run(
        ["git", "rev-parse", "HEAD"],
        capture_output=True,
        text=True,
        check=True
    )
    return result.stdout.strip()


def create_feature(hash_value, commit_hash):
    """Create a new feature file."""
    state = load_state()
    feature_id = state.get("features_created", 0) + 1
    
    features_dir = ROOT_DIR / "features"
    features_dir.mkdir(exist_ok=True)
    
    feature_file = features_dir / f"feature_{feature_id}.txt"
    
    content = f"""# Feature {feature_id}

**Generated by Hash:** {commit_hash[:16]}
**Hash Value:** {hash_value}
**Created:** {datetime.now().isoformat()}

This feature was deterministically created because the commit hash ended in an EVEN number ({hash_value}).

## Feature Description

This is an autonomous feature generated by the hash chain evolution algorithm.
Hash value {hash_value} triggered the creation protocol.

Random seed from hash: {hash(commit_hash) % 1000000}
"""
    
    with open(feature_file, "w") as f:
        f.write(content)
    
    state["features_created"] = feature_id
    save_state(state)
    
    log_evolution(
        "BIRTH",
        hash_value,
        commit_hash,
        f"Created features/feature_{feature_id}.txt based on even hash value {hash_value}.",
        f"The mathematical pulse was EVEN ({hash_value}), triggering a new discovery. Lifeform feature_{feature_id}.txt has been birthed into the digital garden."
    )
    
    print(f"âœ… Created {feature_file}")
    return f"Birthed feature_{feature_id}.txt"


def delete_oldest_feature(hash_value, commit_hash):
    """Delete the oldest feature file."""
    features_dir = ROOT_DIR / "features"
    
    if not features_dir.exists():
        print("âš ï¸  No features directory")
        return "No features to delete"
    
    feature_files = sorted(features_dir.glob("*.txt"))
    
    if not feature_files:
        print("âš ï¸  No features to delete")
        return "No features to delete"
    
    oldest = feature_files[0]
    oldest.unlink()
    
    state = load_state()
    state["features_deleted"] = state.get("features_deleted", 0) + 1
    save_state(state)
    
    log_evolution(
        "DECAY",
        hash_value,
        commit_hash,
        f"Unlinked {oldest.name} triggered by odd hash value {hash_value}.",
        f"The mathematical pulse was ODD ({hash_value}), triggering a natural decay. Oldest lifeform {oldest.name} has been recycled back into the void."
    )
    
    print(f"ðŸ—‘ï¸  Deleted {oldest}")
    return f"Recycled {oldest.name}"


def refactor_files(hash_value, commit_hash):
    """Refactor: rename files with prefixes."""
    features_dir = ROOT_DIR / "features"
    
    if not features_dir.exists():
        return "No features to refactor"
    
    feature_files = list(features_dir.glob("*.txt"))
    
    if not feature_files:
        return "No features to refactor"
    
    renamed_count = 0
    
    for feature_file in feature_files:
        if not feature_file.name.startswith("refactored_"):
            new_name = features_dir / f"refactored_{feature_file.name}"
            feature_file.rename(new_name)
            renamed_count += 1
    
    state = load_state()
    state["refactors"] = state.get("refactors", 0) + 1
    save_state(state)
    
    log_evolution(
        "METAMORPHOSIS",
        hash_value,
        commit_hash,
        f"Applied 'refactored_' prefix to {renamed_count} files based on prime hash value {hash_value}.",
        f"The mathematical pulse was PRIME ({hash_value}), triggering a metamorphosis. {renamed_count} files have evolved with a 'refactored_' prefix."
    )
    
    print(f"ðŸ”§ Refactored {renamed_count} files")
    return f"Evolved {renamed_count} files"


def optimize_files(hash_value, commit_hash):
    """Optimize: compress file content."""
    features_dir = ROOT_DIR / "features"
    
    if not features_dir.exists():
        return "No features to optimize"
    
    feature_files = list(features_dir.glob("*.txt"))
    
    if not feature_files:
        return "No features to optimize"
    
    optimized_count = 0
    
    for feature_file in feature_files:
        with open(feature_file, "r") as f:
            content = f.read()
        
        # Simple optimization: remove extra whitespace
        optimized = "\n".join(line.strip() for line in content.split("\n") if line.strip())
        
        with open(feature_file, "w") as f:
            f.write(optimized)
        
        optimized_count += 1
    
    log_evolution(
        "PURIFICATION",
        hash_value,
        commit_hash,
        f"Minified {optimized_count} files (removed double newlines) triggered by hash multiple of 10 ({hash_value}).",
        f"The mathematical pulse was a multiple of 10 ({hash_value}), triggering a purification. {optimized_count} files have been compressed and cleaned."
    )
    
    print(f"âš¡ Optimized {optimized_count} files")
    return f"Purified {optimized_count} files"


def update_documentation(hash_value, commit_hash):
    """Update documentation."""
    update_readme_stats()
    
    log_evolution(
        "INSCRIPTION",
        hash_value,
        commit_hash,
        f"Regenerated README.md templates based on hash multiple of 7 ({hash_value}).",
        "The mathematical pulse was a multiple of 7, triggering an inscription. The repository's scrolls (README.md) have been updated with new stats."
    )
    
    print("ðŸ“ Updated documentation")
    return "Inscribed new stats"


def create_version_tag(hash_value, commit_hash):
    """Create a version tag."""
    step = get_step_number()
    tag_name = f"v{step}"
    
    try:
        subprocess.run(
            ["git", "tag", "-a", tag_name, "-m", f"Version {step} - Hash: {commit_hash[:8]}"],
            check=True
        )
        subprocess.run(["git", "push", "--tags"], check=True)
        
        log_evolution(
            "MILESTONE",
            hash_value,
            commit_hash,
            f"Git tag creation for v{step} triggered by hash ending in 0 ({hash_value}).",
            f"The pulse ended in 0 ({hash_value}), reaching a new milestone. Created version tag {tag_name} to mark this era."
        )
        
        print(f"ðŸ·ï¸  Created tag {tag_name}")
        return f"Reached milestone {tag_name}"
    except subprocess.CalledProcessError:
        return "Tag creation skipped (may already exist)"


def ingest_environmental_nutrients(hash_value, commit_hash):
    """Ingest GitHub Issues and PRs based on mathematical triggers."""
    actions = []
    
    # Lucky 13: Ingest Issues
    if hash_value % 13 == 0:
        try:
            # Check for open issues
            result = subprocess.run(
                ["gh", "issue", "list", "--limit", "1", "--json", "number,title,author"],
                capture_output=True,
                text=True,
                check=True
            )
            issues = json.loads(result.stdout)
            
            if issues:
                issue = issues[0]
                num = issue["number"]
                title = issue["title"]
                author = issue["author"]["login"]
                
                # Ingest the issue
                feature_name = f"community_discovery_{num}.txt"
                feature_path = ROOT_DIR / "features" / feature_name
                content = f"# Community Discovery: {title}\n\nIngested from Issue #{num} by @{author}\nPulse: {hash_value}\nHash: {commit_hash[:16]}\n"
                
                with open(feature_path, "w") as f:
                    f.write(content)
                
                # Close the issue
                msg = f"The mathematical pulse was a multiple of 13 ({hash_value}), triggering an ingestion. Your discovery has been woven into the chain as `{feature_name}`."
                subprocess.run(["gh", "issue", "close", str(num), "-c", msg], check=True)
                
                # Update state
                state = load_state()
                state["issues_ingested"] = state.get("issues_ingested", 0) + 1
                save_state(state)
                
                log_evolution(
                    "INGESTION",
                    hash_value,
                    commit_hash,
                    f"Parsed Issue #{num} '{title}' and created local asset features/{feature_name}.",
                    f"The garden has 'heard' a human whisper (Issue #{num}). The idea for {title} has been ingested and birthed into the chain."
                )
                actions.append(f"Ingested Issue #{num}")
        except Exception as e:
            print(f"âš ï¸  Issue ingestion failed: {e}")

    # Genetic Prime 17: Ingest PRs
    if hash_value % 17 == 0:
        try:
            # Check for open PRs
            result = subprocess.run(
                ["gh", "pr", "list", "--limit", "1", "--json", "number,title,author"],
                capture_output=True,
                text=True,
                check=True
            )
            prs = json.loads(result.stdout)
            
            if prs:
                pr = prs[0]
                num = pr["number"]
                title = pr["title"]
                author = pr["author"]["login"]
                
                # Record the mutation
                mutation_name = f"mutation_{num}.txt"
                mutation_path = ROOT_DIR / "features" / mutation_name
                content = f"# Genetic Mutation: {title}\n\nIngested from PR #{num} by @{author}\nPulse: {hash_value}\nHash: {commit_hash[:16]}\n"
                
                with open(mutation_path, "w") as f:
                    f.write(content)
                
                # Close the PR
                msg = f"The mathematical pulse was a multiple of 17 ({hash_value}), triggering a genetic ingestion. Your mutation has been recorded in the garden as `{mutation_name}`."
                subprocess.run(["gh", "pr", "close", str(num), "-c", msg], check=True)
                
                # Update state
                state = load_state()
                state["mutations_absorbed"] = state.get("mutations_absorbed", 0) + 1
                save_state(state)
                
                log_evolution(
                    "MUTATION",
                    hash_value,
                    commit_hash,
                    f"Recorded metadata for PR #{num} and closed as merged-by-evolution.",
                    f"The garden has 'absorbed' a human mutation (PR #{num}). The genetic changes proposed in '{title}' are now part of our digital DNA."
                )
                actions.append(f"Absorbed PR #{num}")
        except Exception as e:
            print(f"âš ï¸  PR ingestion failed: {e}")
            
    return actions


def evolve():
    """Main evolution function."""
    print("ðŸ§¬ Starting Hash Chain Evolution...")
    
    # Get current commit hash
    try:
        commit_hash = get_current_commit_hash()
    except subprocess.CalledProcessError:
        print("âš ï¸  No git commits found. Run genesis first.")
        return []

    print(f"Current commit: {commit_hash[:16]}...")

    # Idempotency check: Ensure this hash hasn't been processed yet
    state = load_state()
    if state.get("last_processed_hash") == commit_hash:
        print(f"â­ï¸  Already processed commit {commit_hash[:8]}. Skipping evolution.")
        return []
    
    # Extract hash value (last byte, 0-255)
    hash_value = get_hash_value(commit_hash)
    print(f"Hash value: {hash_value} (0x{hash_value:02X})")
    
    actions_taken = []
    
    # Priority 0: Environmental Nutrients (Issues/PRs)
    actions_taken.extend(ingest_environmental_nutrients(hash_value, commit_hash))
    
    # Priority 1: Version tag (ends in 0)
    if hash_value % 10 == 0 and hash_value > 0:
        result = create_version_tag(hash_value, commit_hash)
        actions_taken.append(result)
    
    # Priority 2: Prime number = refactor
    if is_prime(hash_value):
        result = refactor_files(hash_value, commit_hash)
        actions_taken.append(result)
    
    # Priority 3: Divisible by 10 = optimize
    elif hash_value % 10 == 0 and hash_value > 0:
        result = optimize_files(hash_value, commit_hash)
        actions_taken.append(result)
    
    # Priority 4: Divisible by 7 = documentation
    elif hash_value % 7 == 0 and hash_value > 0:
        result = update_documentation(hash_value, commit_hash)
        actions_taken.append(result)
    
    # Priority 5: Even = create feature
    elif hash_value % 2 == 0:
        result = create_feature(hash_value, commit_hash)
        actions_taken.append(result)
    
    # Priority 6: Odd = delete feature
    else:
        result = delete_oldest_feature(hash_value, commit_hash)
        actions_taken.append(result)
    
    # Record this hash as processed to prevent duplicate runs
    state = load_state() # Reload state in case actions modified it
    state["last_processed_hash"] = commit_hash
    save_state(state)
    
    # Always update README with stats
    update_readme_stats()
    
    print(f"\nâœ¨ Evolution complete!")
    print(f"Actions taken: {', '.join(actions_taken)}")
    
    return actions_taken


if __name__ == "__main__":
    evolve()
