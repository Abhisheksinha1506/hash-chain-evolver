#!/usr/bin/env python3
"""Main evolution script for Hash Chain Evolver."""

import sys
import os
import random
import subprocess
from pathlib import Path
from datetime import datetime
from utils import (
    is_prime, 
    get_hash_value, 
    log_evolution, 
    update_readme_stats,
    save_state,
    load_state,
    get_step_number,
    ROOT_DIR
)


def get_current_commit_hash():
    """Get the current HEAD commit hash."""
    result = subprocess.run(
        ["git", "rev-parse", "HEAD"],
        capture_output=True,
        text=True,
        check=True
    )
    return result.stdout.strip()


def create_feature(hash_value, commit_hash):
    """Create a new feature file."""
    state = load_state()
    feature_id = state.get("features_created", 0) + 1
    
    features_dir = ROOT_DIR / "features"
    features_dir.mkdir(exist_ok=True)
    
    feature_file = features_dir / f"feature_{feature_id}.txt"
    
    content = f"""# Feature {feature_id}

**Generated by Hash:** {commit_hash[:16]}
**Hash Value:** {hash_value}
**Created:** {datetime.now().isoformat()}

This feature was deterministically created because the commit hash ended in an EVEN number ({hash_value}).

## Feature Description

This is an autonomous feature generated by the hash chain evolution algorithm.
Hash value {hash_value} triggered the creation protocol.

Random seed from hash: {hash(commit_hash) % 1000000}
"""
    
    with open(feature_file, "w") as f:
        f.write(content)
    
    state["features_created"] = feature_id
    save_state(state)
    
    log_evolution(
        "ðŸŒ± BIRTH",
        hash_value,
        commit_hash,
        f"A new digital seed has sprouted! Created feature_{feature_id}.txt (triggered by even hash value {hash_value})."
    )
    
    print(f"âœ… Created {feature_file}")
    return f"Created feature_{feature_id}.txt"


def delete_oldest_feature(hash_value, commit_hash):
    """Delete the oldest feature file."""
    features_dir = ROOT_DIR / "features"
    
    if not features_dir.exists():
        print("âš ï¸  No features directory")
        return "No features to delete"
    
    feature_files = sorted(features_dir.glob("feature_*.txt"))
    
    if not feature_files:
        print("âš ï¸  No features to delete")
        return "No features to delete"
    
    oldest = feature_files[0]
    oldest.unlink()
    
    state = load_state()
    state["features_deleted"] = state.get("features_deleted", 0) + 1
    save_state(state)
    
    log_evolution(
        "ðŸ‚ PRUNING",
        hash_value,
        commit_hash,
        f"The garden needed space. Removed the oldest feature {oldest.name} (triggered by odd hash value {hash_value})."
    )
    
    print(f"ðŸ—‘ï¸  Deleted {oldest}")
    return f"Deleted {oldest.name}"


def refactor_files(hash_value, commit_hash):
    """Refactor: rename files with prefixes."""
    features_dir = ROOT_DIR / "features"
    
    if not features_dir.exists():
        return "No features to refactor"
    
    feature_files = list(features_dir.glob("feature_*.txt"))
    
    if not feature_files:
        return "No features to refactor"
    
    renamed_count = 0
    
    for feature_file in feature_files:
        if not feature_file.name.startswith("refactored_"):
            new_name = features_dir / f"refactored_{feature_file.name}"
            feature_file.rename(new_name)
            renamed_count += 1
    
    state = load_state()
    state["refactors"] = state.get("refactors", 0) + 1
    save_state(state)
    
    log_evolution(
        "ðŸ”§ EVOLVE",
        hash_value,
        commit_hash,
        f"Internal reorganization! Renamed {renamed_count} files with a fresh 'refactored_' prefix (triggered by prime hash value {hash_value})."
    )
    
    print(f"ðŸ”§ Refactored {renamed_count} files")
    return f"Refactored {renamed_count} files"


def optimize_files(hash_value, commit_hash):
    """Optimize: compress file content."""
    features_dir = ROOT_DIR / "features"
    
    if not features_dir.exists():
        return "No features to optimize"
    
    feature_files = list(features_dir.glob("*.txt"))
    
    if not feature_files:
        return "No features to optimize"
    
    optimized_count = 0
    
    for feature_file in feature_files:
        with open(feature_file, "r") as f:
            content = f.read()
        
        # Simple optimization: remove extra whitespace
        optimized = "\n".join(line.strip() for line in content.split("\n") if line.strip())
        
        with open(feature_file, "w") as f:
            f.write(optimized)
        
        optimized_count += 1
    
    log_evolution(
        "âš¡ TIGHTEN",
        hash_value,
        commit_hash,
        f"Efficiency boost! Cleaned up and optimized {optimized_count} files (triggered by hash {hash_value} being a multiple of 10)."
    )
    
    print(f"âš¡ Optimized {optimized_count} files")
    return f"Optimized {optimized_count} files"


def update_documentation(hash_value, commit_hash):
    """Update documentation."""
    update_readme_stats()
    
    log_evolution(
        "ðŸ“ ARCHIVE",
        hash_value,
        commit_hash,
        f"Self-reflection! Updated the instruction manual (README) with new stats (triggered by hash {hash_value} being a multiple of 7)."
    )
    
    print("ðŸ“ Updated documentation")
    return "Updated documentation"


def create_version_tag(hash_value, commit_hash):
    """Create a version tag."""
    step = get_step_number()
    tag_name = f"v{step}"
    
    try:
        subprocess.run(
            ["git", "tag", "-a", tag_name, "-m", f"Version {step} - Hash: {commit_hash[:8]}"],
            check=True
        )
        subprocess.run(["git", "push", "--tags"], check=True)
        
        log_evolution(
            "ðŸ·ï¸ MILESTONE",
            hash_value,
            commit_hash,
            f"A major milestone reached! Created version tag {tag_name} (triggered by hash value ending in 0)."
        )
        
        print(f"ðŸ·ï¸  Created tag {tag_name}")
        return f"Created tag {tag_name}"
    except subprocess.CalledProcessError:
        return "Tag creation skipped (may already exist)"


def evolve():
    """Main evolution function."""
    print("ðŸ§¬ Starting Hash Chain Evolution...")
    
    # Get current commit hash
    try:
        commit_hash = get_current_commit_hash()
    except subprocess.CalledProcessError:
        print("âš ï¸  No git commits found. Run genesis first.")
        return []

    print(f"Current commit: {commit_hash[:16]}...")

    # Idempotency check: Ensure this hash hasn't been processed yet
    state = load_state()
    if state.get("last_processed_hash") == commit_hash:
        print(f"â­ï¸  Already processed commit {commit_hash[:8]}. Skipping evolution.")
        return []
    
    # Extract hash value (last byte, 0-255)
    hash_value = get_hash_value(commit_hash)
    print(f"Hash value: {hash_value} (0x{hash_value:02X})")
    
    actions_taken = []
    
    # Determine and execute actions based on hash properties
    
    # Priority 1: Version tag (ends in 0)
    if hash_value % 10 == 0 and hash_value > 0:
        result = create_version_tag(hash_value, commit_hash)
        actions_taken.append(result)
    
    # Priority 2: Prime number = refactor
    if is_prime(hash_value):
        result = refactor_files(hash_value, commit_hash)
        actions_taken.append(result)
    
    # Priority 3: Divisible by 10 = optimize
    elif hash_value % 10 == 0 and hash_value > 0:
        result = optimize_files(hash_value, commit_hash)
        actions_taken.append(result)
    
    # Priority 4: Divisible by 7 = documentation
    elif hash_value % 7 == 0 and hash_value > 0:
        result = update_documentation(hash_value, commit_hash)
        actions_taken.append(result)
    
    # Priority 5: Even = create feature
    elif hash_value % 2 == 0:
        result = create_feature(hash_value, commit_hash)
        actions_taken.append(result)
    
    # Priority 6: Odd = delete feature
    else:
        result = delete_oldest_feature(hash_value, commit_hash)
        actions_taken.append(result)
    
    # Record this hash as processed to prevent duplicate runs
    state = load_state() # Reload state in case actions modified it
    state["last_processed_hash"] = commit_hash
    save_state(state)
    
    # Always update README with stats
    update_readme_stats()
    
    print(f"\nâœ¨ Evolution complete!")
    print(f"Actions taken: {', '.join(actions_taken)}")
    
    return actions_taken


if __name__ == "__main__":
    evolve()
